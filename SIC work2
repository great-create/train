/***********************************************************************/
/*  Program Name: 4-asm_pass1.c                                        */
/*  This program implements Pass 1 of a SIC/XE assembler               */
/*  It builds the SYMTAB and calculates program length                 */
/*  2025.04.27                                                         */
/***********************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Comment out main functions from included files by defining these macros */
#define main main_token
#include "1-token.c"
#undef main

#define main main_optable
#include "2-optable.c"
#undef main

#define main main_pass1_u
#include "3-asm_pass1_u.c"
#undef main

/* Public variables and functions */
#define MAX_SYMBOLS         1000

typedef struct {
    char        symbol[LEN_SYMBOL];
    unsigned    address;
} SYMBOL;

/* Symbol table */
SYMBOL SYMTAB[MAX_SYMBOLS];
int sym_count = 0;

/* Program variables */
unsigned LOCCTR = 0;
unsigned START_ADDR = 0;
unsigned PROGRAM_LENGTH = 0;
char PROGRAM_NAME[LEN_SYMBOL] = "";
char BASE_REGISTER[LEN_SYMBOL] = "";

int add_symbol(char *symbol, unsigned address);
int find_symbol(char *symbol);
int calculate_instruction_length(LINE *line);
void print_symtab();

/* Calculate the length of an instruction based on its format */
int calculate_instruction_length(LINE *line) {
    if (line->fmt == FMT1) {
        return 1;
    } else if (line->fmt == FMT2) {
        return 2;
    } else if (line->fmt == FMT3) {
        return 3;
    } else if (line->fmt == FMT4) {
        return 4;
    } else {
        /* Handle directives */
        if (strcmp(line->op, "BYTE") == 0) {
            /* BYTE - Calculate based on operand content */
            if (line->operand1[0] == 'C') {
                /* Character constant - each character is 1 byte */
                int len = 0;
                char *p = line->operand1 + 2; /* Skip 'C' and "'" */
                while (*p != '\'' && *p != '\0') {
                    len++;
                    p++;
                }
                return len;
            } else if (line->operand1[0] == 'X') {
                /* Hex constant - each pair of hex digits is 1 byte */
                int len = 0;
                char *p = line->operand1 + 2; /* Skip 'X' and "'" */
                while (*p != '\'' && *p != '\0') {
                    len++;
                    p++;
                }
                return len / 2 + (len % 2); /* Round up for odd number of digits */
            }
        } else if (strcmp(line->op, "WORD") == 0) {
            /* WORD directive is 3 bytes */
            return 3;
        } else if (strcmp(line->op, "RESB") == 0) {
            /* RESB - Reserve n bytes */
            return atoi(line->operand1);
        } else if (strcmp(line->op, "RESW") == 0) {
            /* RESW - Reserve n words (1 word = 3 bytes) */
            return 3 * atoi(line->operand1);
        }
    }
    return 0; /* For directives like START, END, BASE, etc. */
}

/* Add a symbol to the symbol table */
int add_symbol(char *symbol, unsigned address) {
    if (sym_count >= MAX_SYMBOLS) {
        return 0; /* Symbol table is full */
    }
    
    /* Check if symbol already exists */
    if (find_symbol(symbol) != -1) {
        return 0; /* Symbol already exists */
    }
    
    strcpy(SYMTAB[sym_count].symbol, symbol);
    SYMTAB[sym_count].address = address;
    sym_count++;
    return 1;
}

/* Find a symbol in the symbol table */
int find_symbol(char *symbol) {
    for (int i = 0; i < sym_count; i++) {
        if (strcmp(SYMTAB[i].symbol, symbol) == 0) {
            return i;
        }
    }
    return -1; /* Symbol not found */
}

/* Print the symbol table */
void print_symtab() {
    printf("\nSymbol Table:\n");
    for (int i = 0; i < sym_count; i++) {
        printf("    %s : %06X\n", SYMTAB[i].symbol, SYMTAB[i].address);
    }
}

/* Compare function for qsort */
int compare_symbols(const void *a, const void *b) {
    return strcmp(((SYMBOL*)a)->symbol, ((SYMBOL*)b)->symbol);
}

int main(int argc, char *argv[]) {
    int line_count;
    int result;
    LINE line;

    if (argc < 2) {
        printf("Usage: %s fname.asm\n", argv[0]);
        return 1;
    }

    if (ASM_open(argv[1]) == NULL) {
        printf("File not found!!\n");
        return 1;
    }

    /* First line should be START directive */
    result = process_line(&line);
    if (result == LINE_CORRECT) {
        if (strcmp(line.op, "START") == 0) {
            /* Set starting address */
            START_ADDR = strtol(line.operand1, NULL, 16);
            LOCCTR = START_ADDR;
            
            /* Save program name if provided */
            if (strlen(line.symbol) > 0) {
                strcpy(PROGRAM_NAME, line.symbol);
            }
            
            /* Print first line */
            printf("%06X  %-8s %-8s %-8s\n", LOCCTR, line.symbol, line.op, line.operand1);
        } else {
            /* If no START directive, assume starting at address 0 */
            LOCCTR = 0;
        }
    }

    /* Process remaining lines (Pass 1) */
    for (line_count = 2; (result = process_line(&line)) != LINE_EOF; line_count++) {
        if (result == LINE_CORRECT) {
            /* Store symbol in symbol table if present */
            if (strlen(line.symbol) > 0) {
                add_symbol(line.symbol, LOCCTR);
            }
            
            /* Print current line */
            printf("%06X  %-8s %-8s %-8s", LOCCTR, line.symbol, line.op, line.operand1);
            if (strlen(line.operand2) > 0) {
                printf(",%-8s", line.operand2);
            }
            printf("\n");
            
            /* Handle BASE directive */
            if (strcmp(line.op, "BASE") == 0) {
                strcpy(BASE_REGISTER, line.operand1);
            }
            /* Handle END directive */
            else if (strcmp(line.op, "END") == 0) {
                /* End of program */
                PROGRAM_LENGTH = LOCCTR - START_ADDR;
                break;
            }
            /* Regular instruction or directive */
            else {
                /* Increase LOCCTR by instruction length */
                LOCCTR += calculate_instruction_length(&line);
            }
        } else if (result == LINE_COMMENT) {
            /* Print comment line (optional) */
            printf("       . Comment line\n");
        } else if (result == LINE_ERROR) {
            /* Print error line */
            printf("       ERROR in line %d\n", line_count);
        }
    }

    /* If no END directive encountered, calculate program length */
    if (PROGRAM_LENGTH == 0) {
        PROGRAM_LENGTH = LOCCTR - START_ADDR;
    }

    /* Print program length */
    printf("\nProgram length = %X\n", PROGRAM_LENGTH);
    
    /* Sort symbol table alphabetically */
    qsort(SYMTAB, sym_count, sizeof(SYMBOL), compare_symbols);
    
    /* Print symbol table */
    print_symtab();
    
    ASM_close();
    return 0;
}
